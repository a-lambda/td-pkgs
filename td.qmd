---
title: "TD développement de package"
---

## Introduction

*Nous allons reprendre votre package `{squirrels}` qui sert de fil rouge tout au long de la formation.*

*Utlisez la table des matières de ce document pour naviguer plus facilement dans les différentes sections.*

*Les solutions de ce TD vous seront fournies dans `/shared` à la fin de chaque étape, sous la forme de fichiers `flat_*.Rmd` et `dev_history.Rmd`.*

## Test unitaires

### Tester la fonction `get_message_fur_color()`

- Ajoutez des vérifications à votre fonction `get_message_fur_color()`

Pour le moment, vous vous êtes seulement assuré.e que la fonction renvoyait bien `"We will focus on Cinnamon squirrels"` lorsqu’on utilisait `get_message_fur_color(primary_fur_color = "Cinnamon")`. Mais vous pouvez ajouter des vérifications supplémentaires.

- Regonflez votre package avec ces nouveaux tests unitaires

- Observez la sortie de la commande suivante :

```{r}
#| label: devtools_test
#| eval: false

devtools::test()

```

### Ajouter et tester la fonction `check_primary_color_is_ok()`

- Ajoutez un nouveau fichier flat dédié à la vérification des données

```{r}
#| label: add_flat_template
#| eval: false

fusen::add_flat_template(template  = "additional",
                         flat_name = "check_data")

```

- Définissez un nouveau nom pour la future vignette (dans le chunk d’inflate)

```{r}
#| label: inflate
#| eval: false

fusen::inflate(flat_file     = "dev/flat_check_data.Rmd", 
               vignette_name = "Check data")

```

- Intégrez-y la fonction `check_primary_color_is_ok()`

```{r}
#| label: add_function_check_primary_color_is_ok
#| eval: false

#' Check the values of primary fur color
#'
#' @param string Character. A vector with the primary fur color.
#'
#' @return Boolean. TRUE if all colors are correct.
#' @export
#'
#' @examples
check_primary_color_is_ok <- function(string) {
  all_colors_OK <- all(
    string %in% c("Gray", "Cinnamon", "Black", NA)
  )
  return(all_colors_OK)
}

```

- Modifiez cette fonction `check_primary_color_is_ok()` de telle manière à ce qu’elle renvoie une erreur si le vecteur n’est pas OK (le message d’erreur doit être explicite)

- N'oubliez pas les exemples et les tests

### Vérifier le package

- Votre package doit retourner 0 errors 0 warnings 0 notes

- Vérifiez que votre package peut s’installer sans encombres

```{r}
#| label: build_and_install_local
#| eval: false

devtools::build(vignettes = TRUE) # construit le package au format tar.gz
remotes::install_local(path = "~/squirrels_0.0.0.9000.tar.gz") # installe le package depuis le format tar.gz

```

> **Est-ce que les fonctions `get_message_fur_color()` et `check_primary_color_is_ok()` sont accessibles ?**

## Documentation du package

- Construisez le site web pkgdown

- Ajoutez un README qui explique en quoi consiste ce package dédié aux écureuils

*Vous pouvez vous inspirer de celui de [{fusen}](https://github.com/ThinkR-open/fusen/blob/main/README.Rmd)^[https://github.com/ThinkR-open/fusen/blob/main/README.Rmd], et y intégrer cet hex si vous le souhaitez (disponible dans le dossier `data` de bakacode) :*

![](images/squirrels_hex.png){ width="25%" }

- Ajoutez un Code of Conduct

- Ajoutez un fichier NEWS

- Construisez de nouveau le site web pkgdown

- Construisez le rapport de coverage

> **Votre package doit retourner 0 errors 0 warnings 0 notes**

## Et si on recommençait tout depuis le début ?

- Créez un package `{squirrels2}` qui contient tous les éléments vus jusqu’ici. Les fonctions (avec exemples reproductibles et tests), la documentation, etc.

> **Votre package doit retourner 0 errors 0 warnings 0 notes**

> **Pour vous aider vous pouvez d’ores et déjà suivre la procédure condensée que vous trouverez dans** `docs/procedure_package_fusen.html`

## Données

### Données accessibles à l'utilisateur final

- Créez un jeu de données `data_act_squirrels` qui sera accessible à l’utilisateur avec `data(data_act_squirrels)`

  - Utilisez le fichier `nyc_squirrels_act_sample.csv` (présent dans votre dossier `data` de bakacode)

  - Gardez uniquement 15 lignes de ce jeu de données
  
  - Documentez ce jeu de données et de mettez la documentation à jour avec `attachment::att_amend_desc()`
  
  - Installez votre package, vérifiez que `data(data_act_squirrels)` et `?data_act_squirrels` fonctionnent correctement
  
### Données stockées dans `inst/`

- Intégrez le fichier `nyc_squirrels_sample.csv` dans `inst/` (présent dans votre dossier `data` de bakacode)

- Dans le fichier flat `flat_check_data.Rmd`, créez une fonction `check_squirrel_data_integrity()` qui prend comme input un jeu de données comme celui-ci et vérifie son intégrité :

  - La fonction vérifie que les données contiennent une colonne `primary_fur_color`, et cette colonne ne doit contenir que des couleurs autorisées (voir votre fonction `check_primary_color_is_ok()`)
  
  - Arrêter la fonction si ce n’est pas le cas
  
  - Retourner un message si tout est correct
  
- Créez un exemple reproductible en utilisant le jeu de données enregistré dans `inst/` avec `system.file()`

  - Pensez que vous pouvez simuler l’installation des données avec `pkgload::load_all()`
  
- Créez des tests unitaires avec des exemples où la fonction doit échouer

> **Votre package doit retourner 0 errors 0 warnings 0 notes**

## Check

- Relancez le check de votre package et assurez-vous qu’il renvoie 0 errors 0 warnings 0 notes

- Si ce n’est pas le cas, prenez du temps pour corriger les problèmes

## Versionnement

### Mise en place du versionnement

- Créez un projet sur GitLab

  - Il doit être créé dans le sous-groupe qui vous est dédié, fraîchement créé par votre formateurice
  
  - Il doit être en mode “public”
  
  - Il doit porter le nom de votre package : `squirrels`
  
  - Invitez le membre `examinateur@thinkr.fr` sur votre repo, et attribuez lui des droits de **Maintainer**. Pour cela, allez dans *Project information > Members > Invite members*
  
- Transformez votre package en projet git

```{r}
#| label: use_git
#| eval: false

usethis::use_git()

```

- Créez le lien entre le projet GitLab et le projet RStudio

### Premières modifications versionnées

- Faites une modification sur le README de votre package

- Commit / Push

## Vérification des paramètres

### Ajouter la fonction `study_activity()`

- Dans votre fichier flat `flat_study_squirrels.Rmd`, intégrez la fonction `study_activity()` :

```{r}
#| label: study_activity
#| eval: false

#' Study the activities of the squirrels given a primary fur color
#'
#' @param df_squirrels_act Data frame. A dataset with the activities of the squirrels. This dataset mush have at leat these 4 columns: "age", "primary_fur_color", "activity", "counts".
#' @param col_primary_fur_color Character. The color of the primary fur color of interest. Only the squirrels with this primary fur color will be considered in the analysis.
#' 
#' @importFrom dplyr filter
#' @importFrom ggplot2 ggplot aes geom_col scale_fill_manual labs
#'
#' @return A list of two named elements. The first one is the filtered table. The second one is the ggplot.
#' @export
#'
#' @examples
study_activity <- function(df_squirrels_act, col_primary_fur_color) {
  
  if(isFALSE(is.data.frame(df_squirrels_act))) {
    stop("df_squirrels_act is not a data frame")
  }
  
  if(isFALSE(is.character(col_primary_fur_color))) {
    stop("col_primary_fur_color is not a character vector")
  }
  
  
  table <- df_squirrels_act |> 
    filter(primary_fur_color == col_primary_fur_color)
    
  graph <- table |> 
    ggplot() +
    aes(x = activity, y = counts, fill = age) +
    geom_col() +
    labs(x = "Type of activity",
         y = "Number of observations",
         title = glue("Type of activity by age for {tolower(col_primary_fur_color)} squirrels")) +
    scale_fill_manual(name = "Age",
                      values = c("#00688B", "#00BFFF"))
  
  return(list(table = table, graph = graph))
}

```

- Cette fonction `study_activity()` utilise plusieurs nouveaux packages. Pensez à les ajouter dans votre chunck de développement afin de les rendre disponibles pour les développeurs.

- Ajoutez un appel à `check_squirrel_data_integrity()` au tout début de la fonction pour vous assurer de l’intégrité des données

- Ajoutez un exemple :

```{r}
#| label: study_activity_example
#| eval: false

data(data_act_squirrels)
study_activity(df_squirrels_act      = data_act_squirrels, 
               col_primary_fur_color = "Gray")

```

- Ajoutez des tests unitaires

- Réalisez un inflate de votre fichier flat. Le check de votre package doit renvoyer : `0 errors, 0 warnings`

- Capturez l’état de votre package avec un commit

> **Ne pas tenir compte des notes sur les global functions ou variables**

### Créer la fonction `save_as_csv()`

- Dans votre fichier flat `flat_study_squirrels.Rmd`, créez une fonction `save_as_csv()` qui :

  - prend en paramètres un **jeu de données** et une chaîne de caractères qui correspond au chemin du fichier qui doit être créé
  
  - permet d’enregistrer le jeu de données en csv avec la fonction `write.csv2()` du package `{utils}` au **chemin spécifié**
  
  - renvoie en sortie le chemin complet du csv créé
  
  - vérifie les différents paramètres de l’utilisateur:
  
    - Vous pouvez vérifier que le jeu de données est bien de classe `data.frame`
    
    - Vous pouvez vérifier que le jeu de données n’a pas un nombre de lignes nul
    
    - Vous pouvez vérifier que la chaîne de caractères qui correspond au chemin du fichier a bien l’extension .csv (voir la fonction `file_ext()` du package `{tools}`)
    
    - Vous pouvez vérifier que le dossier dans lequel doit être stocké le fichier existe
    
**Pour vous aider :**

- Ces lignes doivent fonctionner :
  
```{r}
#| label: tests_sans_erreur
#| eval: false

# Création d'un dossier temporaire
mon_dossier_temp <- tempfile(pattern = "savecsv")
dir.create(mon_dossier_temp)

# ok : le fichier .csv est enregistré dans le projet actuel
iris |> save_as_csv(file.path(mon_dossier_temp, "output.csv"))

# ok : le fichier .csv est enregistré et le fichier s'ouvre
iris |> save_as_csv(file.path(mon_dossier_temp, "output.csv")) |> browseURL()  

```
  
- Ces lignes doivent retourner une erreur explicite :

```{r}
#| label: tests_avec_erreur
#| eval: false

# erreur : l'extension du fichier à créer n'est pas la bonne
iris |> save_as_csv(file.path(mon_dossier_temp, "output.xlsx")) 

# erreur : la fonction n'est pas appliquée à un data.frame
NULL |> save_as_csv(file.path(mon_dossier_temp, "output.csv"))

# erreur : le chemin où doit être enregistré le fichier n'existe pas
iris |> save_as_csv(file.path(mon_dossier_temp, "nexiste/pas/output.csv")) 

```

- En guise d’exemple reproductible de votre fonction, faites en sorte d’exporter la table créée en sortie de la fonction `study_activity()` que vous avez intégrée précédemment

  - Exportez le fichier csv dans un dossier temporaire pour ne pas polluer le package
  
- En vous aidant de la documentation de la fonction `study_activity()`, ajoutez la documentation pour la fonction `save_as_csv()`

- Ajoutez des tests unitaires

- Réalisez un inflate de votre fichier flat. Le check de votre package doit renvoyer : `0 errors, 0 warnings`

- Capturez l’état de votre projet avec un commit et pushez vos modifications sur le remote

> **Ne pas tenir compte des notes sur les global functions or variables lors du check**

### Versionner les développements

- Versionner les développements

- Pushez vos modifications une fois vos modifications terminées

- Votre remote doit contenir vos deux nouvelles fonctions

*Message à destination des formateurices :*

> **Ouvrir une issue sur le projet GitLab de chaque apprenant(e):**

- Ouvrez **une issue par apprenant.e** dont le titre est : *“[bug] Modifier la fonction save_as_csv() pour avoir la possibilité de modifier l’encodage”*



